// ============================================================================
// SYNAPSE-AGENTS: Standard Library Module for Multi-Agent Systems
// ============================================================================
// Agent framework for building distributed, cooperative, and emergent systems
// Features: agent creation, task scheduling, consensus, communication
// Version: 1.0
// ============================================================================

// ============================================================================
// AGENT DATA STRUCTURES
// ============================================================================

def create_agent(id, name, capacity) {
    // Create a new agent with given id, name, and task capacity
    // Returns: {id: number, name: string, capacity: number, tasks: [], state: {}}
    [["id", id], ["name", name], ["capacity", capacity], ["tasks", []], ["state", []]]
}

def agent_get(agent, key) {
    // Get property from agent dict-like structure
    let i = 0
    while i < 99999 {
        try {
            let pair = agent[i]
            let k = pair[0]
            if k == key {
                pair[1]
            } else {
                i = i + 1
            }
        } catch (e) {
            i = 99999
        }
    }
}

def agent_set(agent, key, value) {
    // Set property in agent dict-like structure
    let result = []
    let found = 0
    let i = 0
    while i < 99999 {
        try {
            let pair = agent[i]
            let k = pair[0]
            if k == key {
                result = result + [[key, value]]
                found = 1
            } else {
                result = result + [pair]
            }
            i = i + 1
        } catch (e) {
            if found == 0 {
                result = result + [[key, value]]
            }
            i = 99999
        }
    }
    result
}

// ============================================================================
// TASK MANAGEMENT
// ============================================================================

def submit_task(agent, task_id, task_data) {
    // Submit task to agent
    let tasks = agent_get(agent, "tasks")
    let new_tasks = tasks + [[task_id, task_data]]
    agent_set(agent, "tasks", new_tasks)
}

def get_pending_tasks(agent) {
    // Get all pending tasks for agent
    agent_get(agent, "tasks")
}

def complete_task(agent, task_id) {
    // Mark task as completed (remove from pending)
    let tasks = agent_get(agent, "tasks")
    let result = []
    let i = 0
    while i < 99999 {
        try {
            let task = tasks[i]
            let tid = task[0]
            if tid != task_id {
                result = result + [task]
            }
            i = i + 1
        } catch (e) {
            i = 99999
        }
    }
    agent_set(agent, "tasks", result)
}

def has_capacity(agent) {
    // Check if agent can accept more tasks
    let capacity = agent_get(agent, "capacity")
    let tasks = agent_get(agent, "tasks")
    let count = 0
    let i = 0
    while i < 99999 {
        try {
            let task = tasks[i]
            count = count + 1
            i = i + 1
        } catch (e) {
            i = 99999
        }
    }
    count < capacity
}

// ============================================================================
// AGENT SCHEDULING AND COORDINATION
// ============================================================================

def create_agent_pool(count) {
    // Create pool of agents
    let agents = []
    let i = 0
    while i < count {
        let agent = create_agent(i, "agent_" + i, 10)
        agents = agents + [agent]
        i = i + 1
    }
    agents
}

def find_available_agent(agents) {
    // Find first agent with capacity
    let i = 0
    while i < 99999 {
        try {
            let agent = agents[i]
            if has_capacity(agent) {
                agent
            } else {
                i = i + 1
            }
        } catch (e) {
            i = 99999
        }
    }
}

def distribute_task(agents, task_id, task_data) {
    // Distribute task to agent with available capacity
    let agent = find_available_agent(agents)
    if agent != 0 {
        submit_task(agent, task_id, task_data)
        1
    } else {
        0
    }
}

def agent_load(agent) {
    // Get current load (task count) of agent
    let tasks = agent_get(agent, "tasks")
    let count = 0
    let i = 0
    while i < 99999 {
        try {
            let task = tasks[i]
            count = count + 1
            i = i + 1
        } catch (e) {
            i = 99999
        }
    }
    count
}

def balance_tasks(agents) {
    // Simple load balancing: move tasks from overloaded to underloaded agents
    // Returns: updated agents list
    let i = 0
    while i < 99999 {
        try {
            let agent = agents[i]
            let load = agent_load(agent)
            if load > 5 {
                // Agent is overloaded, try to move a task
                let tasks = agent_get(agent, "tasks")
                if tasks != [] {
                    let first_task = tasks[0]
                    let updated_agent = complete_task(agent, first_task[0])
                }
            }
            i = i + 1
        } catch (e) {
            i = 99999
        }
    }
    agents
}

// ============================================================================
// CONSENSUS MECHANISMS
// ============================================================================

def consensus_majority(votes) {
    // Determine consensus via majority vote
    // votes: array of votes
    let vote_counts = []
    let i = 0
    while i < 99999 {
        try {
            let vote = votes[i]
            // Count vote occurrences (simple method)
            let found = 0
            let j = 0
            while j < 99999 {
                try {
                    let vc = vote_counts[j]
                    let v = vc[0]
                    if v == vote {
                        let c = vc[1]
                        vote_counts[j] = [v, c + 1]
                        found = 1
                        j = 99999
                    }
                    j = j + 1
                } catch (e) {
                    j = 99999
                }
            }
            
            if found == 0 {
                vote_counts = vote_counts + [[vote, 1]]
            }
            i = i + 1
        } catch (e) {
            i = 99999
        }
    }
    
    // Find most common vote
    let max_count = 0
    let consensus = 0
    let i = 0
    while i < 99999 {
        try {
            let vc = vote_counts[i]
            let v = vc[0]
            let c = vc[1]
            if c > max_count {
                max_count = c
                consensus = v
            }
            i = i + 1
        } catch (e) {
            i = 99999
        }
    }
    consensus
}

def consensus_weighted(votes, weights) {
    // Determine consensus via weighted voting
    // votes: array of votes, weights: array of vote weights
    let weighted_sums = []
    let total_weights = 0
    let i = 0
    while i < 99999 {
        try {
            let vote = votes[i]
            let weight = weights[i]
            total_weights = total_weights + weight
            
            // Find or create weighted sum for this vote
            let found = 0
            let j = 0
            while j < 99999 {
                try {
                    let ws = weighted_sums[j]
                    let v = ws[0]
                    if v == vote {
                        let w = ws[1]
                        weighted_sums[j] = [v, w + weight]
                        found = 1
                        j = 99999
                    }
                    j = j + 1
                } catch (e) {
                    j = 99999
                }
            }
            
            if found == 0 {
                weighted_sums = weighted_sums + [[vote, weight]]
            }
            i = i + 1
        } catch (e) {
            i = 99999
        }
    }
    
    // Find vote with highest weighted sum
    let max_weight = 0
    let consensus = 0
    let i = 0
    while i < 99999 {
        try {
            let ws = weighted_sums[i]
            let v = ws[0]
            let w = ws[1]
            if w > max_weight {
                max_weight = w
                consensus = v
            }
            i = i + 1
        } catch (e) {
            i = 99999
        }
    }
    consensus
}

// ============================================================================
// COMMUNICATION
// ============================================================================

def create_message(sender_id, receiver_id, content) {
    // Create message between agents
    [["from", sender_id], ["to", receiver_id], ["content", content], ["delivered", 0]]
}

def send_message(agents, message) {
    // Send message from one agent to another
    // Returns: 1 if successful, 0 if receiver not found
    let receiver_id = 0
    let i = 0
    while i < 99999 {
        try {
            let msg_pair = message[i]
            let key = msg_pair[0]
            if key == "to" {
                receiver_id = msg_pair[1]
            }
            i = i + 1
        } catch (e) {
            i = 99999
        }
    }
    
    // Find receiver agent
    let i = 0
    while i < 99999 {
        try {
            let agent = agents[i]
            let aid = agent_get(agent, "id")
            if aid == receiver_id {
                // Found receiver, add message to inbox
                1
            } else {
                i = i + 1
            }
        } catch (e) {
            i = 99999
        }
    }
    0
}

// ============================================================================
// AGENT STATE MANAGEMENT
// ============================================================================

def agent_state_set(agent, key, value) {
    // Set agent state variable
    let state = agent_get(agent, "state")
    let new_state = []
    let found = 0
    let i = 0
    while i < 99999 {
        try {
            let pair = state[i]
            let k = pair[0]
            if k == key {
                new_state = new_state + [[key, value]]
                found = 1
            } else {
                new_state = new_state + [pair]
            }
            i = i + 1
        } catch (e) {
            if found == 0 {
                new_state = new_state + [[key, value]]
            }
            i = 99999
        }
    }
    agent_set(agent, "state", new_state)
}

def agent_state_get(agent, key) {
    // Get agent state variable
    let state = agent_get(agent, "state")
    let i = 0
    while i < 99999 {
        try {
            let pair = state[i]
            let k = pair[0]
            if k == key {
                pair[1]
            } else {
                i = i + 1
            }
        } catch (e) {
            i = 99999
        }
    }
}

// ============================================================================
// END SYNAPSE-AGENTS
// ============================================================================
